[["index.html", "Engineering Production-Grade Shiny Apps Book Club Welcome", " Engineering Production-Grade Shiny Apps Book Club The R4DS Online Learning Community 2022-05-12 Welcome This is a companion for the book Engineering Production-Grade Shiny Apps by Colin Fay, Sébastien Rochette, Vincent Guyader, and Cervan Girard. This companion is available at r4ds.io/epgs. This website is being developed by the R4DS Online Learning Community. Follow along, and join the community to participate. This companion follows the R4DS Online Learning Community Code of Conduct. "],["book-club-meetings.html", "Book club meetings", " Book club meetings Each week, a volunteer will present a chapter from the book. This is the best way to learn the material. Presentations will usually consist of a review of the material, a discussion, and/or a demonstration of the principles presented in that chapter. More information about how to present is available in the github repo. Presentations will be recorded, and will be available on the R4DS Online Learning Community YouTube Channel. "],["about-successful-shiny-apps.html", "Chapter 1 About Successful {shiny} Apps", " Chapter 1 About Successful {shiny} Apps Learning objectives: Intro to shiny Consider application complexity from different viewpoints "],["introduction.html", "1.1 Introduction", " 1.1 Introduction 1.1.1 Motivation for the book (&amp; the bookclub) 1.1.2 Audience for the book (experienced) shiny devs managers 1.1.3 What is “Production”? Used Relied upon Real life impact "],["intro-to-shiny.html", "1.2 Intro to {shiny}", " 1.2 Intro to {shiny} Building apps in R .. without necessarily needing HTML, CSS, JS training Need {shiny} apps always be a proof-of-concept? "],["what-is-a-complex-shiny-application.html", "1.3 What is a complex {shiny} application?", " 1.3 What is a complex {shiny} application? Complexity: [a complex system] defies any single person&#39;s ability to see [and understand] the system as a whole Consequences: Bug chasing Steep learning curve "],["types-of-complexity.html", "1.4 Types of complexity", " 1.4 Types of complexity Developer complexity Implementation Development Deployment Customer / User complexity Interface "],["code-complexity.html", "1.5 Code complexity", " 1.5 Code complexity Lines of code Number of files Cyclomatic complexity Other sources: Inconsistency Indentation Untested code Dependency-bloat Maintenance and Use Merge-conflicts per week … "],["app-complexity.html", "1.6 App complexity?", " 1.6 App complexity? External dependencies: databases, APIs etc Number of contributors "],["what-is-a-successful-shiny-app.html", "1.7 What is a successful {shiny} app?", " 1.7 What is a successful {shiny} app? Existence Accuracy Usability Immortality "],["meeting-videos.html", "1.8 Meeting Videos", " 1.8 Meeting Videos 1.8.1 Cohort 1 Meeting chat log 00:10:22 Ryan Metcalf: https://unleash-shiny.rinterface.com/index.html "],["planning-ahead.html", "Chapter 2 Planning Ahead ", " Chapter 2 Planning Ahead "],["prepare-for-success.html", "2.1 Prepare for Success", " 2.1 Prepare for Success Learning Objectives: Learn the KISS method Establish good version control and CI / Test Comprehend development team hierarchy French proverb: Rome ne fut pas faite toute en un jour. English Translation: Rome was not made all in one day. The chapter is preparing for a project Projects that aren’t planned well encure additional cost to unwrangle bad code Setting Version Control Organizing a hierarchy of personnel The sooner you start with a robust framework the better, and the longer you wait the harder it gets to convert your application to a production-ready one. "],["develop-with-the-kiss-principle.html", "2.2 Develop with the KISS principle", " 2.2 Develop with the KISS principle Definition: Keep It Simple Stupid Kelly Johnson of Lockheed Skunkworks Develop with a common set of tools Tidyverse Dplyr ggplot2 etc… Expand on this topic for military style of lowest common denominator. Simple is success. Various levels of workforce aptitude lead towards varying degrees of success If your team chooses to use abstract packages or web applications, ensure there is a good reason. The more complex you build your orchestration, the harder it will be to find talent to maintain the service. Example: Microsoft or Oracle "],["working-as-a-team-tools-and-structure.html", "2.3 Working as a team: Tools and structure", " 2.3 Working as a team: Tools and structure The choice of tools and how the team is structured is crucial for a successful application. Not entirely like KISS, but close too it. GitHub versus GitLab. Barebones hardware or Containerization. 2.3.1 From the tools point of view Version control and test all things Use Constant Innovation (CI) principles to test all code before committing Breaking things is a natural process of software engineering, notably when working on a piece of code during a long period Be informed that the codebase is broken Be able to identify changes between versions, and potentially, get back in time to a previous codebase Github/GitLab diff-docs. Example: Branch -&gt; Change -&gt; Test -&gt; Commit -&gt; Pull Request -&gt; Merge Small is beautiful Smaller more managable pieces make it easier to develop Teams may even work in parallel (with caution) A large codebase implies that the safe way to work is to split the app into pieces Extract your core “non-reactive” functions, which we will also call the “business logic”, and include them in external files Non-vital linkages (data ingestion pipelines) Page Layout and theming (CSS or branding characteristics) Allows for expansion but won’t break the core 2.3.2 From the team point of view Select a Manager, maybe a stakeholder or project manager. Someone who may or may not work on the codebase but is aware and knowledgeable Select one or more core developers skilled but specific in their field of study Follow git workflow with issue tracking and managing pull requests "],["reference.html", "2.4 Reference", " 2.4 Reference Lemaire, Maude. 2020. Refactoring at Scale. Henry Holt. NOTE: Paid Service "],["meeting-videos-1.html", "2.5 Meeting Videos", " 2.5 Meeting Videos 2.5.1 Cohort 1 "],["structuring-your-project.html", "Chapter 3 Structuring Your Project", " Chapter 3 Structuring Your Project Learning Objectives Learn the golem file structure for building shiny apps Manage Dependencies and Namespace files Apply proper documentation principles for app maintenance, use, and future development Comprehend the future use of golem "],["shiny-app-as-a-package.html", "3.1 {shiny} app as a package", " 3.1 {shiny} app as a package golem is an opinionated framework for building production-ready {shiny} applications learn the basic now…the rest of the book relies on it 3.1.1 What is in a production-grade {shiny} app? Use one single file, or split into two?….that is the question! We will discover, this is an arbitrary question when managing large production level shiny apps Modulizing code will be your success factor It has metadata This could include: naming convention, version numbering, what the app does, who to contact when it breaks….and it WILL break It handles dependencies You need to handle them, and handle them correctly if you want to ensure a smooth deployment to production DESCRIPTION: contains the packages your application depends on NAMESPACE: contains the functions/packages you need to import It’s split into functions When apps get big…spread the wealth to smaller manageable files The smaller files go into the R/ directory It has documentation Document, Document, Document!!! README can be simple like a markdown file Vignettes are a bit more complex, possibly with examples Function documentation could include inline notes You may even create a {pkgdown} webpage for IT and other developers It’s tested Nothing should go to production without being tested. Nothing. examples could include {testhat} There is a native way to build and deploy it Finally, create a tar.gz file to make it easy for distribution 3.1.2 Resources R packages Building a Package that Lasts Writing R Extensions R Package Primer - a Minimal Tutorial "],["using-shiny-modules.html", "3.2 Using {shiny} modules", " 3.2 Using {shiny} modules Modulizing code will be your success factor 3.2.1 Why {shiny} modules? The one million “Validate” buttons problem Creating small namespaces where you can safely define ids without conflicting with other ids in the app When you single app gets bigger….UI and Server exchange may be hundreds or thousands of lines apart. That is a lot of scrolling! Working with a bite-sized codebase if you copy and paste something more than twice, you should make a function {shiny} modules aim at three things: simplify “id” namespacing split the codebase into a series of functions allow UI/Server parts of your app to be reused Most of the time, modules are used to do the two first. In our case, we could say that 90% of the modules we write are never reused, they are here to allow us to split the codebase into smaller, more manageable pieces. 3.2.2 When to use {shiny} modules Start right from the beginning Yes, this takes a bit more time, but you will be saving yourselve volumes in the future (Your future self will love you!) 3.2.3 A practical walkthrough (Big code base example. Talk through the best way to compare) 1. Your first {shiny} module 2. Passing arguments to your modules - UseLink 3.2.4 Communication between modules Three primary ways to share data amongst modules: - Returning a reactive function - The “stratégie du petit r” (to be pronounced with a French accent of course) - The “stratégie du grand R6” Returning values from the module using reactive calls is costly on the server The “stratégie du petit r” creates a sudo database shared amongst modules. More efficent, but not eloquent The “stratégie du grand R6” {R6} package. The best of both worlds may be foreign to some Other approaches: About {tidymodules} "],["structuring-your-app.html", "3.3 Structuring your app", " 3.3 Structuring your app A shiny app has two main components: - Application logic is what makes your {shiny} app interactive - Business logic includes the components with the core algorithms and functions that make your application specific to your area of work 3.3.1 Small is beautiful (bis repetita) Long scripts are almost always synonymous with complexity when it comes to building software 3.3.2 Conventions matter app_*.R (typically app_ui.R and app_server.R) contain the top-level functions defining your user interface and your server function. fct_* files contain the business logic, which are potentially large functions. They are the backbone of the application and may not be specific to a given module. They can be added using {golem} with the add_fct(“name”) function. mod_* files contain a unique module. Many {shiny} apps contain a series of tabs, or at least a tab-like pattern, so we suggest that you number them according to their step in the application. Tabs are almost always named in the user interface, so that you can use this tab name as the file name. For example, if you build a dashboard where the first tab is called “Import”, you should name your file mod_01_import.R. You can create this file with a module skeleton using golem::add_module(“01_import”). utils_* are files that contain utilities, which are small helper functions. For example, you might want to have a not_na, which is not_na &lt;- Negate(is.na), a not_null, or small tools that you will be using application-wide. Note that you can also create utils for a specific module. *_ui_*, for example utils_ui.R, relates to the user interface. *_server_* are files that contain anything related to the application’s back-end. For example, fct_connection_server.R will contain functions that are related to the connection to a database, and are specifically used from the server side. "],["meeting-videos-2.html", "3.4 Meeting Videos", " 3.4 Meeting Videos 3.4.1 Cohort 1 Meeting chat log 00:06:11 Jumping Rivers: Sorry signed in with work account. BRB 00:12:10 Dhiraj Khanna: Hello, this is Dhiraj, sorry I’m late 00:12:21 Federica Gazzelloni: Hello! 00:12:41 Dhiraj Khanna: Glad to be here! 00:12:41 Russ Hyde: Hi Dhiraj 00:15:02 Dhiraj Khanna: NAMESPACE is read only from what I know 00:18:12 Dhiraj Khanna: Vee-nee-ets is how I pronounce :) 00:20:45 Dhiraj Khanna: Get off TrAVIS! 00:21:17 Dhiraj Khanna: GitHub Actions is what he recommends 00:24:53 Dhiraj Khanna: Would it be ok for me to share my screen at some point and talk about my experiences with {golem}? 00:30:08 Dhiraj Khanna: I am not too sure, but the way I look at it is that every tab in my shiny app is a module 00:32:43 Federica Gazzelloni: can we have the link in the chat? 00:35:00 Dhiraj Khanna: It’s for a client and not publicly available bit I could share my screen and show you 00:35:34 Ryan Metcalf: https://connect.thinkr.fr/tidytuesday201942/ 00:43:34 Federica Gazzelloni: R6 package: https://r6.r-lib.org/articles/Introduction.html 00:44:31 Dhiraj Khanna: Is tidymodules a package? Sorry for the ignorance! 00:45:15 Russ Hyde: Yes: https://github.com/Novartis/tidymodules 00:45:25 Dhiraj Khanna: Nice! 00:46:02 Federica Gazzelloni: R6 package provides a type of class which is similar to R’s standard reference classes 00:47:19 Dhiraj Khanna: RPi rocks! "],["introduction-to-golem.html", "Chapter 4 Introduction to Golem ", " Chapter 4 Introduction to Golem "],["meeting-videos-3.html", "4.1 Meeting Videos", " 4.1 Meeting Videos 4.1.1 Cohort 1 "],["the-workflow.html", "Chapter 5 The Workflow ", " Chapter 5 The Workflow "],["meeting-videos-4.html", "5.1 Meeting Videos", " 5.1 Meeting Videos 5.1.1 Cohort 1 "],["user-experience---ux.html", "Chapter 6 User experience - UX", " Chapter 6 User experience - UX Learning objectives: the key factors for a successful app understanding of your audience behavior "],["introduction-1.html", "6.1 Introduction", " 6.1 Introduction This chapter focuses on the key factors for making a Shiny app successful. Figure 6.1: Shiny success The back-yard vs the front-end The first take away of this chapter is that thinking about the “behind the scene” of your building app can be challenging for a successful front-end. "],["simplicity-is-gold.html", "6.2 Simplicity is gold", " 6.2 Simplicity is gold Establish some rules about your app to be: simple the app must be fast usable straightforward easy to approach and use Based on the identification of the destination of the app: for professional use for fun The quicker you understand the interface, the better the user experience (in business) Don’t fight against the app but enjoy it (for fun) Figure 6.2: Yes and No of your app Yes: “self-explanatory” but with detailed explanations an efficient tool No: fight with interface read complex material lose time understanding how to use it Two more important rules: “don’t make me think” “rule of least surprise”: “Principle of Least Astonishment” 6.2.1 How we read the web: Scanning content The second part of this chapter focuses on what your audience is actually seeing about the app. The user of your app doesn’t read everything, but will be searching for “How to”? Figure 6.3: “How to”? The user might act unexpectedly on you app adopt “defensive programming” mindset is a workaround the unexpected: inherent logic in the application: each sub-menu is designed to handle one specific part of your app rational choice: rationality plays a good game but it is less than expected when up to a new app “irrational” choices: examine the back-end for unexpected behaviors \"organisms adapt well enough to ‘satisfice’; they do not, in general, optimize.“ by Herbert A. Simon To be failing gracefully and informatively can sometimes happen, but do not forget to put an informative bug message to avoid a grayish version of the application. Under some conditions you might not have the complete manner of all that is linked with your app (such as widgets in {DT} package) Good practices: add a bug message wrap all server calls (in case of crash reduce the amount of data loss) use a notification function with {shinyalert} and/or {attempt} packages As an example, if we want our app to be connected to a database, we use connect_db() connection in the server(). If the connection fails, we notify the user: conn &lt;- attempt::attempt({ connect_db() }) if (attempt::is_try_error(conn)){ # Notify the user send_notification(&quot;Could not connect&quot;) } else { # Continue computing if the connection was successful continue_computing() } 6.2.2 Building a self-evident app (or at least self-explanatory) self-evident: no demo required self-explanatory: no explanation required A. About the “Rule of Least Surprise” and the “Principle of Least Astonishment” various text customization lead to conventional thinking B. Thinking about progression design a clear pattern of moving forward hide elements at step n+1 until all the requirements are fulfilled at step n. ensure some kind of linear logic through increasing readability compare {tidytuesday201942} to {hexmake} C. Inputs and errors Your user is BUSY BUSY BEE …. In the UI: useShinyFeedback() In the server(): showFeedbackWarning() hideFeedback() ( the notifyjsexample repository link doesn’t work ) "],["the-danger-of-feature-creep.html", "6.3 The danger of feature-creep", " 6.3 The danger of feature-creep Rule of Parsimony: Write a big program only when it is clear by demonstration that nothing else will do. The Art of UNIX Programming (Raymond 2003) 6.3.1 What is feature-creep? The process of adding features to the app that complicate the usage and the maintenance of the product, such as: easier navigation more information more visualizations modifiable elements … What’s behind feature-creep? adding more and more things most often leads to: a slower app worse user experience steeper learning curve 6.3.2 Too much reactivity Prevent the implementation of “full reactivity” This is a very important part of how to make an app working smoothly, releasing the best experience to users. The book reminds that: people make mistakes while using the app be sure your app doesn’t update all the times at any given imputs If the application reacts to all of the moves, the experience using the app can be bad, imagine that all the elements on the app update at any user input The best solution is to add one reactive button to give the user the opportunity to update results once all the changes have been made. 6.3.3 Too much interactivity A. Speed: use the features that assure fast visualizations at a given input B. Visual noise: reduce the numbers of extra features "],["web-accessibility.html", "6.4 Web accessibility", " 6.4 Web accessibility 6.4.1 About accessibility Audience: large audience Figure 6.4: Accessibility in Context 6.4.2 Making your app accessible A. Hierarchy: respect the order of importance B. HTML element: Semantic tags, and tag metadata: without “meanings”: &lt;div&gt; or &lt;span&gt; have a specific “meanings”: meaningful (Semantic tags) &lt;title&gt; or &lt;article&gt; &lt;address&gt;, &lt;video&gt;, or &lt;label&gt; metadata alt we can use the tagAppendAttributes() ui &lt;- function(){ tagList( plotOutput(&quot;plot&quot;) %&gt;% # Adding the `alt` attribute to our plot tagAppendAttributes(alt = &quot;Plot of iris&quot;) ) } It will be crucial to screen-to-speech technology: the software will read the &lt;title&gt; tag, jump to the &lt;nav&gt;, or straight to the ` on the page. C. Navigation: make everything doable with a keyboard textInput() with a validation button and {nter} package # Adapted from https://github.com/JohnCoene/nter library(nter) library(shiny) ui &lt;- fluidPage( # Setting a text input and a button textInput(&quot;text&quot;, &quot;&quot;), # This button will be clicked when &#39;Enter&#39; is pressed in # the textInput text actionButton(&quot;send&quot;, &quot;Do not click hit enter&quot;), verbatimTextOutput(&quot;typed&quot;), # define the rule nter(&quot;send&quot;, &quot;text&quot;) ) server &lt;- function(input, output) { r &lt;- reactiveValues() # Define the behavior on click observeEvent( input$send , { r$printed &lt;- input$text }) # Render the text output$typed &lt;- renderPrint({ r$printed }) } shinyApp(ui, server) D. Color choices: recommended to use provided color composition such as viridis or other specific combinations. Here as an example is the build of a function, but other packages can be used such as {dichromat} packages which simulates color blindness. with_palette &lt;- function(palette) { x &lt;- y &lt;- seq(-8 * pi, 8 * pi, len = 40) r &lt;- sqrt(outer(x^2, y^2, &quot;+&quot;)) z &lt;- cos(r^2) * exp(-r / (2 * pi)) filled.contour( z, axes = FALSE, color.palette = palette, asp = 1 ) } with_palette(matlab::jet.colors) 6.4.3 Evaluating your app accessibility and further reading How to evaluate accessibility? A. Emulate vision deficiency using Google Chrome B. External tools "],["references.html", "6.5 References", " 6.5 References shinyalert Hexmake app Accessibility Freecodecamp - tutorial nter package Color blindness "],["meeting-videos-5.html", "6.6 Meeting Videos", " 6.6 Meeting Videos 6.6.1 Cohort 1 Meeting chat log 00:07:13 Ryan Metcalf: So sorry for my delay in joining team! 00:07:25 Federica Gazzelloni: All good 00:07:41 Federica Gazzelloni: Hello 00:10:03 Russ Hyde: https://r4ds.github.io/bookclub-epgs/ 00:33:34 Ryan Metcalf: https://databank.worldbank.org/source/education-statistics-%5e-all-indicators 00:34:25 Ryan Metcalf: I’m using education as an example of Dataset. I’m referring to the construction of a query to display. LOTS to choose from. To an unfamiliar user, this site is difficult to navigate and produce meaningful results. 00:34:59 Russ Hyde: I think the notifyjs exmaple was moved here; https://github.com/ColinFay/golemexamples/tree/master/golemnotifyjs 00:49:06 Federica Gazzelloni: https://connect.thinkr.fr/hexmake/ 01:02:53 Federica Gazzelloni: thanks Ryan "],["dont-rush-into-coding.html", "Chapter 7 Don’t Rush into Coding ", " Chapter 7 Don’t Rush into Coding "],["meeting-videos-6.html", "7.1 Meeting Videos", " 7.1 Meeting Videos 7.1.1 Cohort 1 Meeting chat log 00:07:13 Ryan Metcalf: So sorry for my delay in joining team! 00:07:25 Federica Gazzelloni: All good 00:07:41 Federica Gazzelloni: Hello 00:10:03 Russ Hyde: https://r4ds.github.io/bookclub-epgs/ 00:33:34 Ryan Metcalf: https://databank.worldbank.org/source/education-statistics-%5e-all-indicators 00:34:25 Ryan Metcalf: I’m using education as an example of Dataset. I’m referring to the construction of a query to display. LOTS to choose from. To an unfamiliar user, this site is difficult to navigate and produce meaningful results. 00:34:59 Russ Hyde: I think the notifyjs exmaple was moved here; https://github.com/ColinFay/golemexamples/tree/master/golemnotifyjs 00:49:06 Federica Gazzelloni: https://connect.thinkr.fr/hexmake/ 01:02:53 Federica Gazzelloni: thanks Ryan "],["setting-up-for-success-with-golem.html", "Chapter 8 Setting Up for Success with {golem}", " Chapter 8 Setting Up for Success with {golem} Learning Objectives Initialize Golem framework Populate the framework with details Review the Folder Structure Comprehend how here works "],["setting-up-for-success-with-golem-1.html", "8.1 Setting up for Success with {golem}", " 8.1 Setting up for Success with {golem} Developer Workflow: PM sets up golem project first steps filled general structure is set project is registered to version control Start to prototyping the UI work on CSS and JS elements work on back-end functionalities Work on integration of everything inside reacitve context "],["create-a-golem.html", "8.2 Create a {golem}", " 8.2 Create a {golem} Install libraries (if required) File -&gt; New Project -&gt; Select “Package for shiny app Using golem” Alternative, see code snippet below. Replace path/to/package with your known namespace. library(here) library(golem) # Creating a golem project from the command line golem::create_golem(path = &quot;~/Documents/GitHub/bookclub-epgs/golex&quot;) You can view your new project directory structure using: # This is what a default {golem} project looks like # Listing the files from the `golex` project using {fs} fs::dir_tree(&quot;golex&quot;) NOTE: If you get and output with fs::dir_tree(\"golex\") your package is working properly "],["setting-things-up-with-dev01_start.html", "8.3 Setting things up with dev/01_start.R", " 8.3 Setting things up with dev/01_start.R dev/01_start.R is the first file that you need to populate and run. 8.3.1 Fill the DESCRIPTION and set options Within the dev/01_start.R file, you need to populate some pertinent information related to your project. NOTE: This is an automated system. Only edit and run this file first as the remaining steps will be completed in sequence for proper packaging process. golem::fill_desc( # The Name of the package containing the App pkg_name = &quot;ipsumapp&quot;, # The Title of the package containing the App pkg_title = &quot;PKG_TITLE&quot;, # The Description of the package containing the App pkg_description = &quot;PKG_DESC.&quot;, # Your First Name author_first_name = &quot;AUTHOR_FIRST&quot;, # Your Last Name author_last_name = &quot;AUTHOR_LAST&quot;, # Your Email author_email = &quot;AUTHOR@MAIL.COM&quot;, # The URL of the GitHub Repo (optional) repo_url = NULL ) Run golem::set_golem_options() function. NOTE: This adds your information to the golem-config.yml file and sets the here package root sentinel. This is important as here manages the /root of your project. If if you change your working directory in the project, you will still be able to create modules and CSS files in their correct folders. 8.3.2 Set common files If you’d like to set your: Liscense, README, Code of Conduct, lifecycle badge, and NEWS,you can do so here. # You can set another license here usethis::use_mit_license( name = &quot;Golem User&quot; ) # Add a README, Code of Conduct, lifecycle badge and NEWS.md # file to your application usethis::use_readme_rmd( open = FALSE ) usethis::use_code_of_conduct() usethis::use_lifecycle_badge( &quot;Experimental&quot; ) usethis::use_news_md( open = FALSE ) Set up your version control account usethis::use_git() 8.3.3 Use recommended elements golem::use_recommended_tests() and golem::use_recommended_deps() sets a default testing infrastructure and adds dependencies to the application. 8.3.4 Add utility functions The next two code snippets (steps) will add various functions which can be used along the process of building your app. # These files will create R/golem_utils_ui.R # and R/golem_utils_server.R golem::use_utils_ui() golem::use_utils_server() For example, using these utilities list_to_li() is a function to turn R lists into an HTML list. Another example is with_red_star() which puts a red astrix next to a mandatory input. 8.3.5 Changing the favicon You have an option of changing icons associated with your app. By default is the golem hex. Should you provide your own favicon library, you can use this code snippet: golem::use_favicon( path = &quot;path/to/favicon&quot;) Once complete, you can move to the second step, dev/02_dev.R "],["setting-infrastructure-for-prototyping.html", "8.4 Setting infrastructure for prototyping", " 8.4 Setting infrastructure for prototyping 8.4.1 Add modules in dev/02_dev.R The golem::add_module() function creates a module in the R folder. Each module created will follow the convention mod_ and mod_*_ui and mod*server to the UI and server functions. # Creating a module skeleton golem::add_module(name = &quot;my_first_module&quot;) Here, you will paste (at the end of the file) that has to be copied and pasted inside your UI and server functions. This is the core of your application and where the development focus begins. 8.4.2 Add CSS and JS files If you have particular “look and feel” of your app in the form "],["meeting-videos-7.html", "8.5 Meeting Videos", " 8.5 Meeting Videos 8.5.1 Cohort 1 Meeting chat log 00:30:05 Russ Hyde: https://www.r-project.org/Licenses/ 00:30:19 Russ Hyde: https://www.r-project.org/Licenses/MIT "],["building-an-ipsum-app.html", "Chapter 9 Building an Ipsum App ", " Chapter 9 Building an Ipsum App "],["learning-outcomes.html", "9.1 Learning Outcomes", " 9.1 Learning Outcomes Importance of Prototyping Guide the client’s focus Use different tools for prototyping different parts of an app Decouple UI, reactivity, and back-end "],["tools.html", "9.2 Tools", " 9.2 Tools {shinipsum} {fakir} usethis::use_vignette "],["prototyping-is-crucial.html", "9.3 Prototyping is crucial", " 9.3 Prototyping is crucial 9.3.1 Prototype, then polish Make things work before working on low-level optimization This makes the engineering process easier Abstraction is hard, and makes the codebase harder to work with It’s hard to identify bottlenecks up front It’s easier to spot mistakes when you have something that can run 9.3.2 The “UI first” approach helps when clarifying: what the app is supposed to do how the app is to work what each team-member is to work on use “the least possible computation” focus on appearance and interactions "],["prototyping-shiny.html", "9.4 Prototyping {shiny}", " 9.4 Prototyping {shiny} 9.4.1 Fast UI prototyping with {shinipsum} {shinipsum} generates random shiny elements example apps: https://engineering-shiny.org/shinipsum/ https://engineering-shiny.org/golemhtmltemplate/ shinipsum::random_ggplot() + labs(title = \"Random plot\") See example app in the book Also suggest {fakir} as source of example / fake datasets for use while building app "],["building-with-rmarkdown.html", "9.5 Building with RMarkdown", " 9.5 Building with RMarkdown Build the back-end without any reactive context Provides some documentation usethis::use_vignette(\"vignetteName\") 9.5.1 Define the content of the application Rendered .Rmd is shareable content Lets you focus on the core algorithm Obliges you to make back-end “application independent” (write well-documented, non-reactive functions etc) 9.5.2 Using the Rmd files as a laboratory notebook keep track of your ideas separation of work across multiple vignettes 9.5.3 Rmd, Vignettes, and documentation first Vignettes are first-class part of package infrastructure They are built during package check; so you have automated check that vignettes continue to work "],["meeting-videos-8.html", "9.6 Meeting Videos", " 9.6 Meeting Videos 9.6.1 Cohort 1 "],["building-the-app-with-golem.html", "Chapter 10 Building the App with {golem} ", " Chapter 10 Building the App with {golem} "],["learning-outcomes-1.html", "10.1 Learning Outcomes", " 10.1 Learning Outcomes Organise and state your dependencies Split up your code into (sub)modules Organise your functions Test everything Automate CI / CD services Golem Example "],["tools-packages-used.html", "10.2 Tools / Packages Used", " 10.2 Tools / Packages Used {attachment} golem::add_[fct|utils|module] usethis::use_[package|test|vignette|coverage|...] devtools::build_vignettes {covr}, {covrpage}, CodeCov and Coveralls CI providers: Travis, GitHub Actions, GitLab CI golem::[cat|make]_dev "],["add-dependencies.html", "10.3 Add dependencies", " 10.3 Add dependencies 10.3.1 Package dependencies Use DESCRIPTION and NAMESPACE to state / organise the package-dependencies golem::use_recommended_deps() 10.3.2 Importing packages and functions DESCRIPTION: which packages are installed when your app is installed NAMESPACE: which functions / packages are imported when app is running Specifying namespace: Manage namespace conflicts (jsonlite::flatten vs purrr::flatten) Use {roxygen2} to import specific functions or use explicit functions package::function() in R/ "],["submodules-and-utility-functions.html", "10.4 Submodules and utility functions", " 10.4 Submodules and utility functions Split your codebase into smaller pieces golem::add_fct(\"helpers\", module = NULL) adds R/fct_helpers.R Organisation: R/utils_ABC.R - small functions used throughout the app (Purpose-centered; eg, formatting) R/fct_DEF.R - larger functions that aren’t module-specific (Topic-centered; eg, db access) R/mod_XXX_[fct|utils]_YYY.R - functions relevant to a specific module golem::add_module(name = \"xxx\", fct = \"yyy\", utils = \"zzz\") "],["add-tests.html", "10.5 Add tests", " 10.5 Add tests usethis::use_test(\"topic\") tests/testthat/test-topic.R "],["documentation-and-code-coverage.html", "10.6 Documentation and code coverage", " 10.6 Documentation and code coverage 10.6.1 Vignette Long format documentation Rmd-first prototyping method Either in inst/ or vignettes/ devtools::build_vignettes() 10.6.2 Code coverage and Continuous Integration Code coverage Assess which lines in your code are covered by the tests in tests/ usethis::use_coverage() ({covr}) Test coverage may be greater, if you have puppeteer / selenium tests covr::package_coverage() Test the important stuff, and test it well Coverage metrics are easily gamed Think about: branch-coverage, not lines-covered will the tests be affected by internal restructuring would restructuring make it easier to test something that currently isn’t covered? Continuous Integration eg, for running tests every time you check in code to GitHub Providers: GitHub Actions, GitLab CI, Circle CI, Jenkins, Travis CI usethis::use_github_action prewritten actions for tests, linting, pkgdown … "],["using-golem-dev-functions.html", "10.7 Using {golem} dev functions", " 10.7 Using {golem} dev functions golem::cat_dev(\"Only prints when options(golem.app.prod = FALSE)\") golem::make_dev(some_function) "],["meeting-videos-9.html", "10.8 Meeting Videos", " 10.8 Meeting Videos 10.8.1 Cohort 1 "],["build-yourself-a-safety-net.html", "Chapter 11 Build Yourself a Safety Net ", " Chapter 11 Build Yourself a Safety Net "],["learning-objectives.html", "11.1 Learning Objectives", " 11.1 Learning Objectives "],["tools-and-resources.html", "11.2 Tools and Resources", " 11.2 Tools and Resources {testthat} shiny::testServer puppeteer Puppeteer Recorder {crrri} {chromote} {crrry} gremlin.js {shinyloadtest} &amp; shinycannon {shinytest} {dockerstats} {renv} Docker "],["testing-your-app.html", "11.3 Testing Your App", " 11.3 Testing Your App What to test: business logic user interface reactive connections application load 11.3.1 Testing the business logic Good practice: business logic (non-reactive) is separated from interactive logic application is inside a package Standard package development tools are available to you testthat devtools library(testthat) meaning_of_life &lt;- function() 42 describe(&quot;The meaning of life&quot;, { it(&quot;is always 42&quot;, { expect_equal(meaning_of_life(), 42) }) }) ## Test passed 🥇 11.3.2 shiny::testServer For testing reactive updates to server-side values library(shiny) # Given the following module computation_module_server &lt;- function(id, multiplier = 10) { moduleServer(id, function(input, output, session) { ns &lt;- NS(id) r &lt;- reactiveValues( value = NULL ) observeEvent(input$selector, { r$value &lt;- input$selector * multiplier }) }) } describe(&quot;&#39;value&#39;&quot;, { it(&quot;updates to &#39;multiplier&#39; * &#39;selector&#39;&quot;, { # with default multiplier testServer(computation_module_server, { session$setInputs(selector = 1) expect_equal(r$value, 10) session$setInputs(selector = 2) expect_equal(r$value, 20) }) # setting a non-default multiplier testServer(computation_module_server, args = list(multiplier = 15), { session$setInputs(selector = 3) expect_equal(r$value, 45) }) }) }) ## Test passed 🎉 11.3.3 Testing the interactive logic Several options available for testing UI and interactivity 11.3.3.1 Puppeteer Mimics a session on the app Puppeteer NodeJS module Google Chrome headless session npm install puppeteer Chrome extension Headless recorder Website Creates scripts for puppeteer and playwright This records button clicks and text input Note: you have to hit TAB after text input or it won’t be recorded [Interactive] Load Hexmake website Load Headless Recorder “Basic Usage” Click “Headless Recorder” Icon in Chrome extensions Click the BIG RED BUTTON Click “Manage Name” on hexmake page Change Name to “dupree” then hit TAB Stop the recording Copy the code to the clipboard const puppeteer = require(&#39;puppeteer&#39;); const browser = await puppeteer.launch() const page = await browser.newPage() await page.goto(&#39;https://connect.thinkr.fr/hexmake/&#39;) await page.setViewport({ width: 898, height: 926 }) await page.waitForSelector(&#39;.row &gt; .col &gt; .rounded &gt; details:nth-child(3) &gt; summary&#39;) await page.click(&#39;.row &gt; .col &gt; .rounded &gt; details:nth-child(3) &gt; summary&#39;) await page.waitForSelector(&#39;#main_ui_1-left_ui_1-pkg_name_ui_1-package&#39;) await page.click(&#39;#main_ui_1-left_ui_1-pkg_name_ui_1-package&#39;) await page.type(&#39;#main_ui_1-left_ui_1-pkg_name_ui_1-package&#39;, &#39;dupree&#39;) await browser.close() # rerun the script node ./examples/ch11/my_puppeteer_script.js /home/russ/github/bookclub-epgs/examples/ch11/my_puppeteer_script.js:2 const browser = await puppeteer.launch() ^^^^^ SyntaxError: await is only valid in async functions and the top level bodies of modules at Object.compileFunction (node:vm:353:18) at wrapSafe (node:internal/modules/cjs/loader:1039:15) at Module._compile (node:internal/modules/cjs/loader:1073:27) at Object.Module._extensions..js (node:internal/modules/cjs/loader:1138:10) at Module.load (node:internal/modules/cjs/loader:989:32) at Function.Module._load (node:internal/modules/cjs/loader:829:14) at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:76:12) This didn’t actually work. Comparing to the book example, and some other puppeteer examples, we see it should probably have looked like this: const puppeteer = require(&#39;puppeteer&#39;); (async () =&gt; { const browser = await puppeteer.launch() const page = await browser.newPage() await page.goto(&#39;https://connect.thinkr.fr/hexmake/&#39;) await page.setViewport({ width: 898, height: 926 }) await page.waitForSelector(&#39;.row &gt; .col &gt; .rounded &gt; details:nth-child(3) &gt; summary&#39;) await page.click(&#39;.row &gt; .col &gt; .rounded &gt; details:nth-child(3) &gt; summary&#39;) await page.waitForSelector(&#39;#main_ui_1-left_ui_1-pkg_name_ui_1-package&#39;) await page.click(&#39;#main_ui_1-left_ui_1-pkg_name_ui_1-package&#39;) await page.type(&#39;#main_ui_1-left_ui_1-pkg_name_ui_1-package&#39;, &#39;dupree&#39;) await browser.close() })() node ./examples/ch11/my_fixed_puppeteer_script.js [Interactive] Try changing the script: use a non-existing selector and see the script fails use puppeteer.lauch({ headless: false }); 11.3.3.2 {crrri} and {crrry} That’s fine, but do we really want to have a node.js env in all our shiny projects? {crrri} {chromote} {crrry} - puppeteer like, tailored for {shiny} Why the strange names? they use the “Chrome remote interface” # to install {crrry} remotes::install_github(&quot;ColinFay/crrry&quot;) # Creating a new test instance test &lt;- crrry::CrrryOnPage$new( # Using the `find_chrome()` function to guess where the # Chrome bin is on our machine chrome_bin = pagedown::find_chrome(), # Launching Chrome on a random available port on our machine # Note that you will need httpuv &gt;= 1.5.2 if you want to use # this function chrome_port = httpuv::randomPort(), # Specifying the page we want to connect to url = &quot;https://connect.thinkr.fr/hexmake/&quot;, # Do everything on the terminal, with no window open headless = TRUE ) # We&#39;ll wait for the application to be ready to accept inputs test$wait_for_shiny_ready() A simple test: we input a package name then check that the updated package name matches our input name new_pkg &lt;- &quot;dupree&quot; pkg_name_selector &lt;- &quot;main_ui_1-left_ui_1-pkg_name_ui_1-package&quot; js_get_pkg &lt;- glue::glue(&quot;$(&#39;#{pkg_name_selector}&#39;).attr(&#39;value&#39;)&quot;) test$shiny_set_input(pkg_name_selector, new_pkg) test$wait_for_shiny_ready() # This (seemingly trivial) test fails: # - test$shiny_set_input doesn&#39;t change the &#39;visible&#39; input # - but, it triggers reactive changes on the server side expect_equal( test$call_js(js_get_pkg)[[&quot;result&quot;]][[&quot;value&quot;]], expected = new_pkg ) That test failed (test$set_shiny_input sets the inputs that are passed to the server). We can use javascript / jquery syntax to set the UI-attached values. new_pkg &lt;- &quot;dupree&quot; pkg_name_selector &lt;- &quot;main_ui_1-left_ui_1-pkg_name_ui_1-package&quot; js_get_pkg &lt;- glue::glue(&quot;$(&#39;#{pkg_name_selector}&#39;).attr(&#39;value&#39;)&quot;) js_set_pkg &lt;- glue::glue(&quot;$(&#39;#{pkg_name_selector}&#39;).attr(&#39;value&#39;, &#39;{new_pkg}&#39;)&quot;) test$call_js(js_set_pkg) test$wait_for_shiny_ready() expect_equal( test$call_js(js_get_pkg)[[&quot;result&quot;]][[&quot;value&quot;]], expected = new_pkg ) test$stop() Available methods: call_js() shiny_set_input() wait_for() click_on_id 11.3.3.3 gremlin 11.3.3.4 {shinytest} Similar to {puppeteer}-based tests Uses snapshots (browser images) to compare before/after source code changes [Interactive] open hexmake repo "],["further-sections.html", "11.4 Further sections", " 11.4 Further sections Did not present on: Testing the app load A reproducible environment and {renv} Docker "],["meeting-videos-10.html", "11.5 Meeting Videos", " 11.5 Meeting Videos 11.5.1 Cohort 1 Meeting chat log 00:35:42 Federica Gazzelloni: puppeteer : https://developers.google.com/web/tools/puppeteer 00:36:17 Federica Gazzelloni: testthat: https://testthat.r-lib.org/ 00:39:34 Federica Gazzelloni: hexmake: https://connect.thinkr.fr/hexmake/ 00:40:21 Federica Gazzelloni: headless-recorder: https://chrome.google.com/webstore/detail/headless-recorder/djeegiggegleadkkbgopoonhjimgehda 01:07:01 Federica Gazzelloni: shinytest: https://rstudio.github.io/shinytest/ "],["version-control.html", "Chapter 12 Version Control", " Chapter 12 Version Control Learning Objectives What version control is Why is important and how can we use it Some extra features "],["introduction-2.html", "12.1 Introduction", " 12.1 Introduction In this chapter we will focus on Git and GitHub as tools for version control, in particular while using RStudio for dealing with projects version control. "],["using-version-control-with-git.html", "12.2 Using version control with Git", " 12.2 Using version control with Git Tools: Git, GitHub or GitLab These tools let you take control of the versions of you project workflow. 12.2.1 Why version control? code disappeared need to integrating changes in my Team’s project workflow several people can synchronize and collaborate on a same project find something back from far way in time safely track changes More info on how to download and install Git and GitHub are located elsewhere: Happy Git book We assume the following: You’ve registered a free GitHub account You’ve installed/updated R and RStudio You’ve installed Git You’ve introduced yourself to Git You’ve confirmed that you can push to / pull from GitHub from the command line You will also need a test repository on GitHub 12.2.2 Git basics: add - commit - push - pull New users might be challenged for username and password. Many general Git tools require authentication. The information that is needed is your PAT. You can stored your PAT with gitcreds::gitcreds_set() command. Once this is done correctly you don’t need to do that again unless you require more strict rules on your VC tool, so that it might require you to regularly update your credentials.1 The basic commands in Git are: add: info or other addition to the project (i.e. Add a line to README and verify that Git notices the change) commit: engage the content with the repository (i.e. in RStudio click the bottom “commit” in the pane section of GitHub) The “commit” button creates a unique commit reference number: sha# And allows the user to make a comment about the commit, so to advise the others in the project or to remind the user about it. push: send the content to the server and so to the repository pull: receive the changes/updates from the repository 12.2.3 About branches The “main” branch is the one that appears at the beginning of the project, but other branches can be created. Secondary branches are work areas, usually for the other in the team to have a further layer of security of the “main” content. When you work on a shared project, your collaborators need to name a new branch to interact with the repository. This imply the creation of mirrored repositories that can be absolutely equal or slightly different, as the requested additions/modifications are accepted. 12.2.4 Issues Issues are another way to advise the main repository of some modifications that would be needed. They are used to propose changes, to track a bug or to suggest a feature, and can be done directly by the GitHub page of the repository. An issue creates a “message exchange” form of communication with the repository owner, for advising about something that can be improved. happygitwithr.com↩︎ "],["git-integration.html", "12.3 Git integration", " 12.3 Git integration 12.3.1 With RStudio In our case we are interested in how to use GitHub with RStudio, and how to set it up in a new project. There are two ways for setting up a project which is linked with a version control software support system, such as GitHub. The experience in using version controls with RStudio would be very beneficial. 12.3.2 As part of a larger world 12.3.3 About git-flow What is a git flow ? It is intended as the Git workflow, and it relates with differentiating the use of the main branch with the developer (dev) branch which is the “working in progress”. While the team merge/pull requests (MR/PR) to dev from a feature branch Branches: main dev feature branch (any given name) hot fix (to correct a critical issue in main) 7 Steps of a software engineer daily work flow: Identify an issue to work on Fork dev into issue-XXX Develop a feature inside the branch. Regularly run git stash, git rebase dev, and git stash apply to include the latest changes from dev to stay synchronized with dev. Make a pull request to dev so that the feature is included. Once the PR is accepted by the project manager, notify the rest of the team that there have been changes to dev, so they can rebase it to the branch they are working on. Start working on a new feature. "],["automated-testing.html", "12.4 Automated testing", " 12.4 Automated testing The book mention some “health check” repository software integration: Travis CI Note that Travis CI can run tests on GNU/Linux or MacOS operating systems Appveyor It supports Windows, as well GitHub actions It is the most common used With Travis usethis::use_travis() the events described in the travis configuration file (.travis.yml) are executed (with a binary outcome: 0/1) before merging any pull request, the project manager has access to a series of tests that are automatically launched. While with GitHub Action the command are the following, the first three perform a standard R CMD check, while use_github_action_pr_commands() sets checks to be performed when a pull request is made to the repository usethis::use_github_action_check_release() use_github_action_check_standard() use_github_action_check_full() use_github_action_pr_commands() One more feature is: GitLab CI service is a Docker-based container "],["conclusions.html", "12.5 Conclusions", " 12.5 Conclusions Version control tools are useful to secure you work against some annoying inconveniences. Also automated procedures would help maintain resilient applications. 12.5.1 Resources Happy Git Git Cheat Sheet A git flow Understanding a git flow GitSvnComparison Git Pro Book Git Branching Basic Branching and Merging GitHub Actions for the R language R CMD check hub.docker "],["meeting-videos-11.html", "12.6 Meeting Videos", " 12.6 Meeting Videos 12.6.1 Cohort 1 Meeting chat log 00:40:00 Russ Hyde: Here are some git resources that I like: https://www.atlassian.com/git/tutorials/syncing (bitbucket&#39;s tutorials on git for teams) https://learngitbranching.js.org/ (a game for learning git branching) 00:40:18 Russ Hyde: Semantic versioning: https://semver.org/ (MAJOR.MINOR.PATCH) 00:50:38 Russ Hyde: The {usethis} pull-request helpers are quite nice too: https://usethis.r-lib.org/articles/articles/pr-functions.html 00:56:02 Russ Hyde: use_github_action_pr_commands() is quite nice. With this in place, you can type `/document` in the discussion on a pull request, and it will run roxygen2 on your package/app; similarly `/style` will run {styler} on your repo 00:57:42 Ryan Metcalf: I’ve only used in a “minor” process (Flask deployment) on Gitlab CI/CD. I haven’t used GitHub as frequently therefore a bit naive towards GitHub Actions. To benefit the future viewer, I found this page beneficial: https://about.gitlab.com/devops-tools/github-vs-gitlab/ci-missing-github-capabilities/ 01:08:57 Russ Hyde: and I always like to push https://www.codetriage.com/ on people. One problem open-source projects have is that there are more issues than time could allow to fix. It&#39;s really useful to identify issues that are duplicated, or otherwise closely related, or that have already been fixed. This website gives those who want to help with open-source a chance to help with triaging github issues (determining whether an issue is _important_). "],["placeholder.html", "Chapter 13 PLACEHOLDER", " Chapter 13 PLACEHOLDER Learning Objectives FILL THESE IN "],["slide-1.html", "13.1 Slide 1", " 13.1 Slide 1 Slide content here "],["meeting-videos-12.html", "13.2 Meeting Videos", " 13.2 Meeting Videos 13.2.1 Cohort 1 Meeting chat log 00:15:57 Training Rivers: Hi everyone 00:16:14 Federica Gazzelloni: Hello 01:04:02 Federica Gazzelloni: ops, ya! 01:04:54 Federica Gazzelloni: it requires a bit of practice.. 01:07:06 Training Rivers: https://cran.r-project.org/web/packages/ReviewR/vignettes/deploy_server.html 01:18:00 Federica Gazzelloni: apologies…I need to go…Thanks Ryan, I will be back to you with asking questions about it 01:18:41 Training Rivers: THanks "],["the-need-for-optimization.html", "Chapter 14 The Need for Optimization", " Chapter 14 The Need for Optimization ** Learning Objectives ** You can optimise for: speed memory maintainability / readability … but not all three When optimising, make sure you have a basis for comparison (of alternative implementations) "],["build-first-then-optimize.html", "14.1 Build first, then optimize", " 14.1 Build first, then optimize 14.1.1 Identifying bottlenecks \"\"“Focusing on optimizing small portions of your app before making it work fully is the best way to lose time along the way, even more in the context of a production application, where there are deadlines and a limited amount of time to build the application.”\"\" When your furniture takes 2 months to cross the ocean, it doesn’t matter whether you have an electric screwdriver It’s hard to know where the bottlenecks will be until your app is working And there’s no point optimising until you know where the bottlenecks are… 14.1.2 Do you need faster functions? \"\"“Of course a function running twice as fast is a good thing, but think about it in context: for example, how many times is this function called? We can safely bet that if your function is only called once, working on making it twice as fast might not be the one function you would want to focus on”\"\" But, what if your single-call function holds everything else up? 14.1.3 Don’t sacrifice readability Possible restructurings: high-level language (R/python) to low-level language (C++/rust) one package to another single to parallel implementation Optimisation trade-off against: maintain-, read-, searchability Example: compare C++ code for computing mean with R code for the same "],["tools-for-profiling.html", "14.2 Tools for profiling", " 14.2 Tools for profiling 14.2.1 Profiling R code {profvis} and the “flame graph” library(profvis) top &lt;- function(){ # We use profvis::pause() because Sys.sleep() doesn&#39;t # show in the flame graph pause(0.1) # Running a series of function with lapply() lapply(1:10, function(x){ x * 10 }) # Calling a lower level function middle() } middle &lt;- function(){ # Pausing before computing, and calling other functions pause(0.2) 1e4 * 9 bottom_a() bottom_b() } # Both will pause and print, _a for 0.5 seconds, # _b for 2 seconds bottom_a &lt;- function(){ pause(0.5) print(&quot;hey&quot;) } bottom_b &lt;- function(){ pause(2) print(&quot;hey&quot;) } profvis({ top() }) Memory: profvis does indicate memory used, but … {profmem} 14.2.1.1 Identifying bottlenecks 14.2.1.2 Benchmarking R code \"\"“never start optimizing if you cannot benchmark this optimization”\"\" Recommend keep a notebook of different implementations that were attempted (for the bottlenecks in your app) {bench} for comparing different implementations checks that outputs are the same # Multiplying each element of a vector going from 1 to size # with a for loop for_loop &lt;- function(size){ res &lt;- numeric(size) for (i in 1:size){ res[i] &lt;- i * 10 } return(res) } # Doing the same thing using a vectorized function vectorized &lt;- function(size){ (1:size) * 10 } res &lt;- bench::mark( for_loop = for_loop(1000), vectorized = vectorized(1000), iterations = 1000 ) 14.2.2 Profiling {shiny} 14.2.2.1 Shiny back-end Can use profvis(print(run_app())) 14.2.2.2 Shiny front-end See: https://engineering-shiny.org/need-for-optimization.html#b.-shiny-front-end 14.2.3 Profiling web pages "],["resources-2.html", "14.3 Resources", " 14.3 Resources {bench} http://bench.r-lib.org/reference/mark.html {profvis} https://rstudio.github.io/profvis/ {profmem} https://github.com/HenrikBengtsson/profmem “Mastering Shiny :: Performance” https://mastering-shiny.org/performance.html “Shiny in Production” talk (Joe Cheng) "],["meeting-videos-13.html", "14.4 Meeting Videos", " 14.4 Meeting Videos 14.4.1 Cohort 1 "],["optimazing-shiny---common-application-caveats.html", "Chapter 15 Optimazing Shiny - Common Application Caveats", " Chapter 15 Optimazing Shiny - Common Application Caveats Learning Objectives Decide what should be optimized. Compare app versions to optimize an app. Read data into your Shiny application. "],["introduction-3.html", "15.1 Introduction", " 15.1 Introduction This chapter focuses on how to optimize common applications when using Shiny. Several versions of the same app are compared to achieve shorter and more understandable structures as well as more stable renderings. "],["reactivity-anti-patterns.html", "15.2 Reactivity anti-patterns", " 15.2 Reactivity anti-patterns A invalidates B which invalidates C which invalidates A which invalidates B which invalidates C, and so on… Figure 15.1: Reactivity an overview Too much reactivity can lead to recursive behaviors. How to handle it: example app set specific steps let the user choose by step For example in the case of selecting dates: dateInput() and the selectInput() updates each other (cac_1) One way to solve this is to add some extra logic to the app by: selectInput() and adding an the observeEvent(input$year, {}) (cac_2) 15.2.1 observe vs observeEvent The main guideline is to use observeEvent() as much as possible, and avoid observe()as much as possible. Looking at the steps taken for building this first example app, we see that changing the text input doesn’t make any difference, but if we add the “reverse” opting, we can see the recursive taking action. In this example we use obeserve(): (cac_3) Figure 15.2: Recursivity How many potential invalidation points we have here? input$txt input$rev input$casefolding It is safer to go with observeEvent(), as it allows you to see at a glance the condition under which the content is invalidated and re-evaluated. Figure 15.3: Recursivity 15.2.2 Building triggers and watchers create “flag” objects with an init function trigg these flags with trigger() invalidate these flags to a reactive context, we watch() these flags To solve this kind of issues, ColinFay provides a package: gargoyle package that provides wrappers around {shiny} to turn your app into and event-based application instead of a full reactive app. The framework is centered around a listen &amp; trigger mechanism. # CRAN version # install.pacKages(&quot;gargoyle&quot;) # Dev version # remotes::install_github(&quot;ColinFay/gargoyle&quot;) gargoyle::init(\"this\") initiates a “this” flag: most of the time you will be generating them at the app_server() level. gargoyle::watch(\"this\") sets the flag inside a reactive context, so that it will be invalidated every time you trigger(“this”) this flag. `gargoyle::trigger(“this”) triggers the flags. (Example of the implemented structure: {hexmake} (Fay 2021g)) A practical example of the implementation uses an environment to store the value. So, do not rely on any reactive value invalidating the reactive context, but the result is rendered on when “render2” flag is triggered. (cac_4) "],["using-r6-as-data-storage.html", "15.3 Using R6 as data storage", " 15.3 Using R6 as data storage The idea is to storage the R functional framework inside an R6 class. R6 is an encapsulated object-oriented programming (OOP) framework, a programming language used to construct the modular pieces of code that can be used to build blocks for large systems. It is used to structure a software program into simple, reusable pieces of code blueprints (classes) to create individual instances (objects). R is a functional programming language which uses R6 object-oriented programming-OOP. Sharing data across modules (field/class) Be sure it is tested (object) R6 R6 Advanced R R6 classes (cac_5) MyData &lt;- R6::R6Class( &quot;MyData&quot;, # Defining our public methods, that will be # the dataset container, and a summary function public = list( data = NULL, initialize = function(data){ self$data &lt;- data }, summarize = function(){ summary(self$data) } ) ) library(testthat, warn.conflicts = FALSE) test_that(&quot;R6 Class works&quot;, { # We define a new instance of this class, that will contain # the mtcars data.frame my_data &lt;- MyData$new(mtcars) # We will expect my_data to have two classes: # &quot;MyData&quot; and &quot;R6&quot; expect_is(my_data, &quot;MyData&quot;) expect_is(my_data, &quot;R6&quot;) # And the summarize method to return a table expect_is(my_data$summarize(), &quot;table&quot;) # We would expect the data contained in the object # to match the one taken as input to new() expect_equal(my_data$data, mtcars) # And the summarize method to be equal to the summary() # on the input object expect_equal(my_data$summarize(), summary(mtcars)) }) ## Test passed 🎊 "],["logging-reactivity-with-whereami.html", "15.4 Logging reactivity with {whereami}", " 15.4 Logging reactivity with {whereami} 15.4.1 What is logging? - What is a reactive logging? Logging is a way to access the log file of the app. It is used to debug the app’s code, and it is a useful feature when debugging someone else’s code. The log file is where all the steps taken by the app are registered, it tells you what your app is doing. So that, being able to access the log file and locate the part that is to be debugged is an important task. To facilitate the location of the “part of the shiny code that is to be debugged” a warning is positioned for simplification of the procedure. There are several packages in R that provide useful functions for logging, here we talk about some specific packages to use within a shiny app. ….whereami is one of them. {whereami} return where the script is run from Figure 15.4: {whereami} package whereami::whereami() (Sidi and Müller 2019 - github ) For example, whereami() function let’s you locate the name of the file you are working on: library(whereami) whereami::whereami() ## ── Running From: ./bookclub-epgs.Rmd ─────────────────────────────────────────── Then, as classical procedure, with the use of the base::cat() function within the logging procedure, the cat_where() function in {whereami} package, helps you to producing an output in a user-defined function. It converts arguments to character vectors and, concatenates them to a single character vector, in the locate file. Where should it be located? If it is added to the app_server(), it will print the location of the function call to the logs. The combination with cat_where() will implement a reactive logging to the console while developing or debugging an app. whereami::cat_where( whereami::whereami() ) cat_where(where, type = c(&quot;rule&quot;, &quot;boxx&quot;, &quot;bullet&quot;, &quot;line&quot;, &quot;print&quot;), color = &quot;some_colors&quot;, ...) Another feature is to get a list of all the counters: the numbers of time each of the located cat functions have been called and plot the statistics of the usage. whereami::counter_get() plot(whereami::counter_get()) Figure 15.5: {whereami} package As an example: library(whereami) require(ggplot2) ggplot(iris) + aes(x=Sepal.Length,y=Sepal.Width) + geom_point() + labs(caption = sprintf(&#39;sourced from: %s&#39;,whereami())) In this context, it is everything we need to know about logging with whereami. More information about in general logging a shiny app can be found here: blog.sellorm.com "],["r-does-too-much.html", "15.5 R does too much", " 15.5 R does too much 15.5.1 Rendering the UI from the server side Change things on the UI based on what happens in the server: A. Implement UI events in JavaScript Adding JavaScript elements would speed up the process, as well as substituting uiOutput() and renderUI() with more direct functions, for example if requested is a text use: textOutput(\"...\") instead of the whole uiOutput(). And in the server renderText(...) instead of renderUI(). (compare cac_6 to cac_7) B. update* inputs Same as using selectInput(...) and updateSelectInput(...) C. insertUI and removeUI Dynamically change what is in the UI is with insertUI() and removeUI() To make the code simpler for the developer and to make an app which is easier to use from a user perspective, there are some strategies that suggest to avoid some common functions, such as: uiOutput() and renderUI(). In general what is happening is that we change things on the UI based on what happens in the server, and for making R not regenerate the whole UI component but only changing what is needed, we can: 15.5.2 Too much data in memory Consider deporting the data handling and computation to an external database system: for example, to an SQL database. "],["reading-data.html", "15.6 Reading data", " 15.6 Reading data 15.6.1 Reading external datasets To include data inside your application: usethis::use_data_raw( name = &quot;my_dataset&quot;, open = FALSE ) command usethis::use_data(my_dataset) 15.6.2 Including data in your application To upload data inside your application: shiny::fileInput() 15.6.3 Using external databases To include data from external databases use: SQL databases designed to store tabular data NoSQL database like MongoDB to write operations, and store any kind of object Example of an app that uses on an external database is {databasedemo}, available at engineering-shiny 15.6.4 Data-source checklist Figure 15.6: Data-source checklist "],["conclusions-1.html", "15.7 Conclusions", " 15.7 Conclusions In conclusion, there are some different ways to optimize an app using extrafeatures such as packages that let you identify the location of the most used part of the app for an easier debugging procedure. Also, to be at knowledge of the tools for uploading and/or deploying external data into the app would require extra consideration of the amount of memory taken for doing the job. 15.7.1 Resources Reactivity an overview blog.sellorm.com whereami "],["meeting-videos-14.html", "15.8 Meeting Videos", " 15.8 Meeting Videos 15.8.1 Cohort 1 Meeting chat log (2021-12-01) 00:06:09 Ryan Metcalf: https://adventofcode.com/ "],["optimizing-shiny-code.html", "Chapter 16 Optimizing {shiny} code", " Chapter 16 Optimizing {shiny} code Learning Objectives Major routes for optimising R/shiny code Cacheing Asynchronous code "],["resources-4.html", "16.1 Resources", " 16.1 Resources Efficient R programming https://csgillespie.github.io/efficientR/ Advanced R https://adv-r.hadley.nz/perf-improve.html Mastering Shiny https://mastering-shiny.org/performance.html RStudio caching blogposts: https://shiny.rstudio.com/articles/plot-caching.html - the old way https://shiny.rstudio.com/articles/caching.html - the new way Packages {R.cache} https://github.com/HenrikBengtsson/R.cache {memoise} https://github.com/r-lib/memoise {future} https://github.com/HenrikBengtsson/future {promises} https://rstudio.github.io/promises "],["caching-elements.html", "16.2 Caching Elements", " 16.2 Caching Elements 16.2.1 What is Caching Store resource-intensive results So they can be reused without recomputation Downside: you can’t cache ’em all Only cache if the thing: would be identical each time it is made (for a given input) Good things to cache: Plots Database queries 16.2.2 Native caching in R {R.cache} and {memoise} work in a similar way: Wrap a function with a higher-order function (new_func &lt;- memoise::memoise(initial_func)) Call the new function with some arguments (new_func(x = 1, y = 2)) it does the expensive computation then stores the result Call the new function again if you’ve used the args before, it will return immediately with the stored result The arguments are converted to a look-up key library(memoise) # tic/toc are used for timing library(tictoc) sleep_and_return_time &lt;- function(seconds = 1) { Sys.sleep(seconds) return(Sys.time()) } msleep_and_return_time &lt;- memoise(sleep_and_return_time) # first call is sloooooooow tic() msleep_and_return_time(10) toc() # second call is fast tic() msleep_and_return_time(10) toc() But …. why is sleep_and_return_time a bad example for a cacheable function? The book has a more reproducible example using database queries (there’s a db-in-shiny example below, so we don’t cover this example) {memoise} stores the cache on disk, you can set where on the file-system it is stored 16.2.3 Caching in {shiny} An app: library(shiny) ui &lt;- function(){ tagList( # The user can select one of the cut from ggplot2::diamonds, # {shiny} will then query the SQL database to retrieve the # first rows of the result selectInput(&quot;cut&quot;, &quot;cut&quot;, unique(ggplot2::diamonds$cut)), tableOutput(&quot;tbl&quot;) ) } srv_builder &lt;- function(con) { server &lt;- function( input, output, session ){ # Rendering the table of the SQL call output$tbl &lt;- renderTable({ # Using a memoised function allows to prevent from # calling the SQL database every time the user inputs # a change memoised_fct_sql(input$cut, con) }) } server } # We create an in-memory database using SQLite con &lt;- DBI::dbConnect( RSQLite::SQLite(), dbname = &quot;:memory:&quot; ) # Writing a large dataset to the db DBI::dbWriteTable( con, &quot;diams&quot;, # This table will have 539400 rows dplyr::bind_rows( purrr::rerun(10, ggplot2::diamonds) ) ) shinyApp(ui, server = srv_builder(con)) What haven’t we defined here? library(memoise) fct_sql &lt;- function(cut, con){ # NEVER EVER SPRINTF AN SQL CODE LIKE THAT # IT&#39;S SENSITIVE TO SQL INJECTIONS, WE&#39;RE # DOING IT FOR THE EXAMPLE cli::cat_rule(&quot;Calling the SQL db&quot;) results &lt;- DBI::dbGetQuery( con, sprintf( &quot;SELECT * FROM diams WHERE cut = &#39;%s&#39;&quot;, cut ) ) head(results) } # Using a local cache cache_dir &lt;- cache_filesystem(&quot;cache&quot;) memoised_fct_sql &lt;- memoise(fct_sql, cache = cache_dir) App workflow: Start the app set input$cut to a new value time how long it takes to render the new table set input$cut to an unused value note that it takes the same length of time set input$cut to the first selected value note that it is way faster than the original call {shiny} already has caching functionality: shiny::bindCache() [older] shiny::renderCachedPlot() Note from the RStudio shiny blog: \"\"“As of Shiny 1.6.0, we recommend using renderPlot() with bindCache() instead”\"\" Example shiny app taken from the book but rewritten to use renderPlot() %&gt;% bindCache() rather than renderCachedPlot() library(shiny) ui &lt;- function() { tagList( # We select a data.frame to plot selectInput( &quot;tbl&quot;, &quot;Table&quot;, c(&quot;iris&quot;, &quot;mtcars&quot;, &quot;airquality&quot;) ), # This plotOutput will be cached plotOutput(&quot;plot&quot;) ) } server &lt;- function( input, output, session ) { # The cache mechanism is made available by &#39;bindCache&#39; output$plot &lt;- renderPlot({ # Plotting the selected data.frame plot(get(input$tbl)) }) %&gt;% bindCache( # List here all the reactive expression that will # be used as cache key when running the app, # you will see that the first time you plot one # graph, it takes a couple of seconds, # but the second time, it&#39;s almost # instantaneous input$tbl ) } shinyApp(ui, server) Notes: you can also cache on remote storage (e.g., S3) you only have limited space - old cached values will be dropped "],["asynchronous-in-shiny.html", "16.3 Asynchronous in {shiny}", " 16.3 Asynchronous in {shiny} R is single threaded but the world isn’t B and C depend on A D depends on B and C Synchronous code: either A -&gt; B -&gt; C -&gt; D or A -&gt; C -&gt; B -&gt; D If B runs on another computer and takes a long time Synchronous version: A -&gt; start-B retrieve-B -&gt; C -&gt; D \\ / (My-server) \\ / --------------- - run-B - (Remote-server) Asynchronous version: A -&gt; start-B -&gt; C -&gt; retrieve-B -&gt; D \\ / (My-server) \\ / --------------- - run B ---- (Remote-server) Packages: {future}: send computation elsewhere {promises}: objects for handling async computation 16.3.1 Asynchronously ease cross-session issues One R/shiny session Multiple users A few, specific, long-running operations “Promise” = A stand-in for the eventual result of an operation - https://rstudio.github.io/promises/articles/intro.html - %...&gt;% - Promise-compatible pipe - What happens on success - %...!% - What happens on failure library(shiny) library(future) library(promises) plan(multisession) ui &lt;- function(){ tagList( # This will receive the output of the future verbatimTextOutput(&quot;rnorm&quot;) ) } server &lt;- function( input, output, session ){ output$rnorm &lt;- renderPrint({ # Sending the rnorm to be run in another session future({ Sys.sleep(20) return(rnorm(5)) }) %...&gt;% print(.) %...!% stop(.) }) } s &lt;- shinyApp(ui, server) runApp(s, launch.browser = FALSE) Plan: run the above launch the app in two separate browser windows (X and Y) wait 20 seconds If one session blocked the other: X results would show at ~ 20secs Y results at ~ 40secs If there is no cross-session blocking Both X and Y results would show at ~ 20secs 16.3.2 Asynchronously ease within-session issues Compare this (which blocks): ... output$rnorm &lt;- renderPrint({ # Sending the rnorm to be run in another session # At this point, {shiny} is waiting for the future # to be solved before doing anything else future({ Sys.sleep(3) return(rnorm(5)) }) %...&gt;% print(.) %...!% stop(.) }) ... with this (which doesn’t block): rv &lt;- reactiveValues( output = NULL ) future({ Sys.sleep(5) rnorm(5) }) %...&gt;% # When the future is resolved, we assign the # output to rv$output (function(result){ rv$output &lt;- result }) %...!% # If ever the future outputs an error, we switch # back to NULL for rv$output, and throw a warning # with the error (function(error){ rv$output &lt;- NULL warning(error) }) # output$rnorm will be printed whenever rv$output # is available (i.e. after around 5 seconds) output$rnorm &lt;- renderPrint({ req(rv$output) }) 16.3.3 Common Pitfalls The first future sent needn’t be the first to return bookkeeping: check whether the future that returns is the one you need do you need the final future? (use an identifier) do you need the futures in sequence? (use a queue) "],["meeting-videos-15.html", "16.4 Meeting Videos", " 16.4 Meeting Videos 16.4.1 Cohort 1 Meeting chat log 00:07:38 Ryan Metcalf: https://www.scootersoftware.com/ 00:13:41 Ryan Metcalf: http://www.math.rug.nl/~trentelman/jacob/pdflatex/pdflatex.html 00:15:28 Ryan Metcalf: One more link for you Federica: https://community.rstudio.com/t/rstudio-cant-find-pdflatex/49790 00:15:56 Federica Gazzelloni: this is mine: https://tug.org/mactex/faq/3-4.html 01:02:16 Federica Gazzelloni: library(promises) ?”%…&gt;%” 01:02:38 Federica Gazzelloni: https://rstudio.github.io/promises/articles/overview.html#using-pipes 01:08:58 Ryan Metcalf: Link isn’t related to R necessarily, but does add a comparison or a more general framework towards Asynchronous web services. In the example, use Apache as the back end and Nginx managing the treading to the backend servers (Apache). I entered this world in eLearning and latency in rendering videos and SCORM content. https://www.digitalocean.com/community/tutorials/apache-vs-nginx-practical-considerations 01:16:16 Dhiraj Khanna: I did use asynchronous programming in Shiny a while back. Found it to be quite useful while fetching external data using an API that took a long time. The benefit of using async is that multiple users who are trying to make a call at the same time will not have to wait for one another, but it does come at a cost of a fairly large overhead. At least for me 01:18:55 Dhiraj Khanna: Adding async will make the call much slower for each person. So the tradeoff is either making the call fast for each single session, but multiple sessions have to queue up, OR making the call a bit slower but multiple sessions can run in parallel. 01:19:55 Ryan Metcalf: Good comment Dhiraj. This would make sense for sure! 01:22:51 Dhiraj Khanna: I am not too sure but I think shinyproxy kind of helps in parallel processing and multi threading "],["using-javascript.html", "Chapter 17 Using JavaScript", " Chapter 17 Using JavaScript Learning Objectives Interact with {shiny} apps using JavaScript 🚀 blasting your work into the ether Manipulate UI and Server linkages with JavaScript Learn the various methods to apply JavaScript to your {shiny} app Understand how to reference elements of a HTML Document using JavaScript Comprehend the differences between JavaScript and jQuery "],["introduction-4.html", "17.1 Introduction", " 17.1 Introduction This is a HUGE chapter!!! But then, again, JavaScript is a HUGE subject! JavaScript is maintained by the European Computer Manufacturers Association (ECMA). JavaScript is often referred to as ECMA Script. Where do I use Javascript? Here are just a few examples: Interactive Webpages (Radio Buttons, Text Entry, dynamic changing of page attributes) eLearning (SCORM, xAPI) Data Visualization (D3JS) You are using it to Knit this Markdown as well as provide all sorts of interaction! Javascript is one of three primary standards that make up the World Wide Web Consortium (W3C). Other standards include: HyperText Markup Language (HTML) Cascading Style Sheets (CSS) Standard Vectors Graphics (SVG) jQuery (a derivative of JavaScript. Considered more lightweight) Asynchronous JavaScript And XML (AJAX) This may all appear confusing, but the reality is, most R developers who deploy {shiny} apps may not even leave RStudio. Therefore, one could claim the primary reason for adding additional JavaScript is to add hyper performance to your web app! Note, at this point, I’m not calling it a {shiny} anymore, but a web app. But what is going on under the hood? {shiny} binds events to UI elements, and these JavaScript events will communicate with R R talks to your browser through a web socket Communication happens in both directions "],["a-quick-introduction-to-javascript.html", "17.2 A quick introduction to JavaScript", " 17.2 A quick introduction to JavaScript The fastest way to interact with JavaScript is from the Developer Tools of your favorite browser For example, enter the following in your Dev Tools Console: var message = \"Hello World\"; alert(message); 17.2.1 Including JavaScript code in your app There are three primary ways to include JavaScript code in your app: As an external file Inside a &lt;script&gt;Your Code snippet goes here&lt;/script&gt; tag Inline, on a specific tag The recommended practice is through an external file. If you are developing with {golem}, there are two primary functions to include JavaScript. They are: golem::add_js_file(\"name\"), this adds a standard JavaScript file. This method is not intended to communicate with R golem::add_js_handler(\"name\"), this is intended to work with R golem::add_js_binding(\"name\"), for advanced, customer interaction for your shiny app 17.2.2 Understanding HTML, class, and id Think of your Web Page as a tree where the top of the page is your root node. Referenced as the Document Object Model (DOM) You can work on any of these HTML nodes with JavaScript The following code snippets compare R code to its corresponding HTML output: library(shiny) fluidPage( titlePanel(&quot;Hello Shiny&quot;), textInput(&quot;act&quot;, &quot;Input&quot;) ) And its corresponding HTML: &lt;div class=&quot;container-fluid&quot;&gt; &lt;h2&gt;Hello Shiny&lt;/h2&gt; &lt;div class=&quot;form-group shiny-input-container&quot;&gt; &lt;label class=&quot;control-label&quot; for=&quot;act&quot;&gt;Input&lt;/label&gt; &lt;input id=&quot;act&quot; type=&quot;text&quot; class=&quot;form-control&quot; value=&quot;&quot;/&gt; &lt;/div&gt; &lt;/div&gt; We can see we created a div tag with a Bootstrap container, an h2 tag for text, and a text input field with and id and class. NOTE: id must be unique. This is how the websockets can communicate Elements can have a class which can apply to multiple elements. This can be used in JavaScript, but it is also very useful for styling elements in CSS. 17.2.3 Querying in Vanilla JavaScript The term Vanilla JavaScript refers to plain JavaScript, meaning, not external plugins. // Given &lt;div id = &quot;first&quot; name=&quot;number&quot; class = &quot;widediv&quot;&gt;Hey&lt;/div&gt; // Query with the ID document.querySelector(&quot;#first&quot;) document.getElementById(&quot;first&quot;) // With the class document.querySelectorAll(&quot;.widediv&quot;) document.getElementsByClassName(&quot;widediv&quot;) // With the name attribute document.getElementsByName(&quot;number&quot;) // Using the tag name document.getElementsByTagName(&quot;div&quot;) This method comes with a hitch! Not all Browsers are created equal! This brings another angle of development consideration to our software development process. With relation to proprietary frameworks and a host of different Browser vendors (Mozilla Firefox, Google Chrome, Apple Safari, etc…) not all JavaScript versions are recognized. 17.2.4 About DOM Events Within the Document Object Model, interactions are called events. JavaScript runtime is listening for these events. Better yet, this is were we can control the interaction of our users with our {shiny} apps. The following are examples of events: click / dblclick focus keypress, keydown, keyup mousedown, mouseenter, mouseleave, mousemove, mouseout, mouseover, mouseup scroll For a full list of these events, please visit this link. Once you have this list in mind, you can select elements in the DOM, add an addEventListener to them, and define a callback function (which is executed when the event is triggered) &lt;input type=&quot;text&quot; id = &quot;firstinput&quot;&gt; &lt;script&gt; document.getElementById(&quot;firstinput&quot;).addEventListener( &quot;keypress&quot;, function(){ alert(&quot;Pressed!&quot;) } ) &lt;/script&gt; Another example is to send an alert when the Shiny Server is connected: $(document).on(&#39;shiny:connected&#39;, function(event) { alert(&#39;Connected to the server&#39;); }); The $() is considered jQuery and is a subset, lighter weight, more widely recognized method of running JavaScript. 17.2.5 About jQuery and jQuery selectors jQuery is native to the {shiny} package. Examples of jQuery include: $(\"#firstinput\") to refer to the element with the id firstinput $(\".widediv\") to refer to element(s) of class widediv $(\"button:contains('this')\") to refer to the buttons with a text containing 'this' &lt;a href = &quot;https://thinkr.fr&quot; data-value = &quot;panel2&quot;&gt;ThinkR&lt;/a&gt; We can interact with these attributes using jQuery: $(\"a[href = 'https://thinkr.fr']\") refers to link(s) with href being https://thinkr.fr $('a[data-value=\"panel2\"]') refers to link(s) with data-value being \"panel2\" NOTE: jQuery has the advantage of simplifying selections and actions and is a cross-platform library "],["client-side-javascript.html", "17.3 Client-Side JavaScript", " 17.3 Client-Side JavaScript This whole topic is related to JavaScript, but is stated with relation to R and Shiny. These three are all intertwined with each other. If extend beyond R and {shiny}, you can expand the interaction of your web app. Examples include: Small JavaScript functions that will prevent you from writing complex algorithmic logic in your application server. alert(\"message\") is a built-in alert-box mechanism. This is built into the user’s browser and can replace a call to the server, like shinyalert. var x = prompt(\"this\", \"that\"); is a function that opens a built-in prompt window. We can recieve input and store it in a variable for future use. 17.3.1 Common Patterns Examples of Client-Side use of JavaScript: alert(\"message\") is a built-in alert-box mechanism. This is built into the user’s browser and can replace a call to the server, like shinyalert. var x = prompt(\"this\", \"that\"); is a function that opens a built-in prompt window. We can recieve input and store it in a variable for future use. $('#id').css('color', 'green');, or in vanilla JavaScript document.getElementById(\"demo\").style.color = \"green\"; changes the CSS attributes of the selected element(s). Here, we are switching to green on the #id element. $(\"#id\").text(\"this\"), or in vanilla JavaScript document.getElementById(\"id\").innerText = \"this\"; changes the text content to “this”. $(\"#id\").remove();, or in vanilla JavaScript var elem = document.querySelector('#some-element'); elem.parentNode.removeChild(elem); completely removes the element from the DOM. It can be used as a replacement for shiny::removeUI(), or as a conditional UI. Note that this code doesn’t remove the input values on the server side: the elements only disappear from the UI, but nothing is sent to the server side. 17.3.2 Where to put them: Back to JavaScript Events It is great we are discussing all levels of JavaScript implementation…but where to put them? Here are some examples of adding JavaScript functions to DOM events: onclick The onclick attribute can be added straight inside the HTML tag when possible: # Building a button using the native HTML tag # (i.e. not using the actionButton() function) # This button only goal is to launch this JS code # when it is clicked tags$button( &quot;Show&quot;, onclick = &quot;$(&#39;#plot&#39;).show()&quot; ) Or with shiny::tagAppendAttributes(): # Using tagAppendAttributes() allows to add attributes to the # outputed UI element plotOutput( &quot;plot&quot; ) %&gt;% tagAppendAttributes( onclick = &quot;alert(&#39;hello world&#39;)&quot; ) Here is, for example, a small {shiny} app that implements this behavior: library(shiny) library(magrittr) ui &lt;- function(){ fluidPage( # We create a plotOutput, which will show an alert when # it is clicked plotOutput( &quot;plot&quot; ) %&gt;% tagAppendAttributes( onclick = &quot;alert(&#39;iris plot!&#39;)&quot; ) ) } server &lt;- function(input, output, session){ output$plot &lt;- renderPlot({ plot(iris) }) } shinyApp(ui, server) Lets put this into Golem!!! Use the add_js_file(\"name\") function in Golem. In /inst/app/www/script.js function alertme(id){ // Asking information var name = prompt(&quot;Who are you?&quot;); // Showing an alert alert(&quot;Hello &quot; + name + &quot;! You&#39;re seeing &quot; + id); } Then in R plotOutput( &quot;plot&quot; ) %&gt;% tagAppendAttributes( # Calling the function which has been defined in the # external script onclick = &quot;alertme(&#39;plot&#39;)&quot; ) Last example, you can also add jQuery calls too! Inside this inst/app/www/script.js, you can also attach a new behavior with jQuery to one or several elements. For example, you can add this alertme / onclick behavior to all plots of the app: function alertme(id){ var name = prompt(&quot;Who are you?&quot;); alert(&quot;Hello &quot; + name + &quot;! You&#39;re seeing &quot; + id); } /* We&#39;re adding this so that the function is launched only when the document is ready */ $(function(){ // Selecting all `{shiny}` plots $(&quot;.shiny-plot-output&quot;).on(&quot;click&quot;, function(){ /* Calling the alertme function with the id of the clicked plot */ alertme(this.id); }); }); We’ve unpacked a lot here…but there is more. Check out JavaScript Events in {shiny} for the full list of JavaScript events available in {shiny}. "],["javascript---shiny-communication.html", "17.4 JavaScript &lt;-&gt; {shiny} Communication", " 17.4 JavaScript &lt;-&gt; {shiny} Communication Now that we have seen some client-side optimization, i.e. R does not do anything with these events when they happen (in fact R is not even aware they happened). 17.4.1 From R to JavaScript Calling JS from the server side (i.e. from R) is done by defining a series of CustomMessageHandler functions: these are functions with one argument that can then be called using the session$sendCustomMessage() method from the server side.Or if you are using {golem}, using the invoke_js() function. Using the skeleton from golem::add_js_handler(\"first_handler\"), we get this snippet: $( document ).ready(function() { Shiny.addCustomMessageHandler(&#39;fun&#39;, function(arg) { }) }); Then, you can call it from the server side: session$sendCustomMessage(&quot;fun&quot;, list()) # OR golem::invoke_js(&quot;fun&quot;, ...) NOTE: the list() argument will be coverted to JavaScript Object Notation (JSON) and read via JavaScript. If we have function x and variables a and b, then we can use the dot notation of x.a and x.b in our JavaScript. For Example: // We define a handler called &quot;computed&quot;, that can be called // from the server side of the {shiny} application Shiny.addCustomMessageHandler(&#39;computed&#39;, function(mess) { // The received value (in mess) is serialized in JSON, // so we can access the list element with object.name alert(&quot;Computed &quot; + mess.what + &quot; in &quot; + mess.sec + &quot; secs&quot;); }) And within R: observe({ # Register the starting time deb &lt;- Sys.time() # Mimic a long computation Sys.sleep( sample(1:5, 1) ) # Calling the computed handler golem::invoke_js( &quot;computed&quot;, # We send a list, that will be turned into JSON list( what = &quot;time&quot;, sec = round(Sys.time() - deb) ) ) }) 17.4.2 From JavaScript to R How can you do the opposite (send JavaScript calls to R)? There is an object called Shiny within your browser. This object can be used to send values to R by creating an InputValue. // This function from the Shiny JavaScript object // Allows to register an input name, and a value Shiny.setInputValue(&quot;rand&quot;, Math.random()) You bind an input which can be caut fro the server side using: # Once the input is set, it can be caught with R using: observeEvent( input$rand , { print( input$rand ) }) Shiny.setInputValue cn be used inside any JavaScript function. As an example we use the following code snippet: In inst/app/www/script.js function alertme(){ var name = prompt(&quot;Who are you?&quot;); alert(&quot;Hello &quot; + name + &quot;! Welcome to my app&quot;); Shiny.setInputValue(&quot;username&quot;, name) } $(function(){ // Waiting for `{shiny}` to be connected $(document).on(&#39;shiny:connected&#39;, function(event) { alertme(); }); $(&quot;.shiny-plot-output&quot;).on(&quot;click&quot;, function(){ /* Calling the alertme function with the id of the clicked plot. The `this` object here refers to the clicked element*/ Shiny.setInputValue(&quot;last_plot_clicked&quot;, this.id); }); }); The above snippet gets the user name and last plot clicked. We can catch the call to the server using the following snippet: # We wait for the output of alertme(), which will set the # &quot;username&quot; input value observeEvent( input$username , { cli::cat_rule(&quot;User name:&quot;) print(input$username) }) # This will print the id of the last clicked plot observeEvent( input$last_plot_clicked , { cli::cat_rule(&quot;Last plot clicked:&quot;) print(input$last_plot_clicked) }) Which will give: &gt; golex::run_app() Loading required package: shiny Listening on http://127.0.0.1:5495 ── User name: ───────────────────────────────────────────────────── [1] &quot;Colin&quot; ── Last plot clicked: ───────────────────────────────────────────── [1] &quot;plota&quot; ── Last plot clicked: ───────────────────────────────────────────── [1] &quot;plotb&quot; NOTE: If you are using modules, you will need to pass the namespacing of the id to be able to get it back from the server. This can be accomplished using the session$ns function. This comes by default using any golem-generated module. Example of a session$ns call used in Golem Module: $( document ).ready(function() { // Setting a custom handler that will // ask the users their name // then set the returned value to a Shiny input Shiny.addCustomMessageHandler(&#39;whoareyou&#39;, function(arg) { var name = prompt(&quot;Who are you?&quot;) Shiny.setInputValue(arg.id, name); }) }); mod_my_first_module_ui &lt;- function(id){ ns &lt;- NS(id) tagList( actionButton( ns(&quot;showname&quot;), &quot;Enter your name&quot; ) ) } mod_my_first_module_server &lt;- function(input, output, session){ ns &lt;- session$ns # Whenever the button is clicked, # we call the CustomMessageHandler observeEvent( input$showname , { # Calling the &quot;whoareyou&quot; handler golem::invoke_js( &quot;whoareyou&quot;, # The id is namespaced, # so that we get it back on the server-side list( id = ns(&quot;name&quot;) ) ) }) # Waiting for input$name to be set with JavaScript observeEvent( input$name , { cli::cat_rule(&quot;Username is:&quot;) print(input$name) }) } "],["about-shinyjs-js-functions.html", "17.5 About {shinyjs} JS functions", " 17.5 About {shinyjs} JS functions As mentioned at the beginning of the chapter, running JavaScript code you don’t fully control/understand can be tricky and may open vulnerabilities. It is always safer to use proven packages that have been tested and passed efficiency. For example shinyjs. See deanattali.com/shinyjs/ for more information. "],["one-last-thing-api-calls.html", "17.6 One last thing: API calls", " 17.6 One last thing: API calls If you ShinyApp uses API calls, there are good chances you are already doing this from R. However, there may be downsides to this approach. As an example, if you are limited by API calls (Twitter API, Google Map API). Due to these restrictions your end user may be limited in using your app. A work around is instead of using your Server’s IP to make the API call, wrap it in Javascript so you use your user’s IP instead! This allows your ShinyApp to scale. You use the fetch() JavaScript function to make API calls. For an example: tags$button(\"Get Me One!\", onclick = \"get_rand_beer()\"). Below is a general skeleton that works with an API that does not require authentication and returns a JSON object. Inside JavaScript (here, we create a function that will be available on an onclick event): // FUNCTION definition const get_rand_beer = () =&gt; { // Fetching the data fetch(&quot;https://api.punkapi.com/v2/beers/random&quot;) // What do we do when we receive the data .then((data) =&gt;{ // TTurn the data to JSON data.json().then((res) =&gt; { // Send the json to R Shiny.setInputValue(&quot;beer&quot;, res, {priority: &#39;event&#39;}) }) }) // Define what happens if we fail to fetch .catch((error) =&gt; { alert(&quot;Error catching result from API&quot;) }) }; Observe the event in your server: observeEvent( input$beer , { # Do things with beer }) NOTE: The data shared between R and JavaScript is serialized to JSON, so you will have to manipulate the format once you recieve it in R. Learn more about fetch() at Using Fetch. "],["learn-more-about-javascript.html", "17.7 Learn more about JavaScript", " 17.7 Learn more about JavaScript If you want to interact straight with R using NodeJS, you can use the {bubble} package. Obviously, you need to have NodeJS installed on your machine to use this service. Install {bubble} from GitHub: remotes::install_github(&quot;ColinFay/bubble&quot;) You can use it in RMarkdown chunks by setting the knitr engine: bubble::set_node_engine() Or straight from command line with: node_repl() Here is a list of external resources to learn more about JavaScript: 17.7.1 {shiny} and JavaScript We have written an online, freely available book about {shiny} and JavaScript: JavaScript 4 {shiny} - Field Notes. JavaScript for {shiny} Users, companion website to the rstudio::conf(2020) workshop. Build custom input objects. Packaging JavaScript code for {shiny}. Communicating with {shiny} via JavaScript. 17.7.2 JavaScript basics Mozilla JavaScript w3schools JavaScript Free Code Camp JavaScript for Cats Learn JS 17.7.3 jQuery jQuery Learning Center w3schools jQuery 17.7.4 Intermediate/advanced JavaScript Eloquent JavaScript You Don’t Know JS Yet "],["meeting-videos-16.html", "17.8 Meeting Videos", " 17.8 Meeting Videos 17.8.1 Cohort 1 Meeting chat log 00:10:56 Ryan Metcalf: This is a side project I’m working through…..nothing of presentation yet: https://xapi.com/overview/?utm_source=google&amp;utm_medium=natural_search 00:19:45 Federica Gazzelloni: @Russ can you put the title of the book? 00:19:59 russ: &quot;Javascript for R&quot; 00:20:08 russ: John Coene 00:20:09 Federica Gazzelloni: is there any pdf or free available resource for that? 00:21:04 russ: https://book.javascript-for-r.com/ 00:21:23 Federica Gazzelloni: thanks! 00:48:26 russ: Standard generalized markup language 01:13:24 Federica Gazzelloni: https://shiny.rstudio.com/articles/communicating-with-js.html 01:18:02 Federica Gazzelloni: little example app that continuously sends rainbow colors from R to JavaScript Meeting chat log 00:27:29 Federica Gazzelloni: the plot was the one with iris facets 00:44:13 Federica Gazzelloni: get_rand_beer () =&gt; {FETCHING THE API DATA} 00:57:20 Federica Gazzelloni: https://www.r-bloggers.com/2020/05/fetch-api-results-from-the-browser-and-send-them-to-shiny/ 01:06:15 Federica Gazzelloni: that is js language 01:12:24 Federica Gazzelloni: apologies but I have another meeting …. thanks for this session @ryan and @russ for facilitating "],["a-gentle-introduction-to-css.html", "Chapter 18 A Gentle Introduction to CSS", " Chapter 18 A Gentle Introduction to CSS Learning Objectives What CSS does CSS is already used by {shiny} How to write custom CSS Integration of custom CSS with {shiny} "],["what-is-css.html", "18.1 What is CSS", " 18.1 What is CSS CSS “Cascading style sheets” Encodes webpage design View a page without CSS (“Web Developer” -&gt; CSS -&gt; Disable All Styles) 18.1.1 Default CSS for {shiny} Without fluidPage: library(shiny) my_tags &lt;- tagList( h1(&quot;Hey&quot;), h2(&quot;You&quot;), p(&quot;You rock!&quot;), selectInput(&quot;what&quot;, &quot;Do you&quot;, unique(iris$Species)) ) ui1 &lt;- function(){ my_tags } ui2 &lt;- function(){ fluidPage(my_tags) } empty_server &lt;- function(input, output, session){} shinyApp(ui1, empty_server) shinyApp(ui2, empty_server) Show the HTML print(ui1()) ## &lt;h1&gt;Hey&lt;/h1&gt; ## &lt;h2&gt;You&lt;/h2&gt; ## &lt;p&gt;You rock!&lt;/p&gt; ## &lt;div class=&quot;form-group shiny-input-container&quot;&gt; ## &lt;label class=&quot;control-label&quot; id=&quot;what-label&quot; for=&quot;what&quot;&gt;Do you&lt;/label&gt; ## &lt;div&gt; ## &lt;select id=&quot;what&quot;&gt;&lt;option value=&quot;setosa&quot; selected&gt;setosa&lt;/option&gt; ## &lt;option value=&quot;versicolor&quot;&gt;versicolor&lt;/option&gt; ## &lt;option value=&quot;virginica&quot;&gt;virginica&lt;/option&gt;&lt;/select&gt; ## &lt;script type=&quot;application/json&quot; data-for=&quot;what&quot; data-nonempty=&quot;&quot;&gt;{&quot;plugins&quot;:[&quot;selectize-plugin-a11y&quot;]}&lt;/script&gt; ## &lt;/div&gt; ## &lt;/div&gt; print(ui2()) ## &lt;div class=&quot;container-fluid&quot;&gt; ## &lt;h1&gt;Hey&lt;/h1&gt; ## &lt;h2&gt;You&lt;/h2&gt; ## &lt;p&gt;You rock!&lt;/p&gt; ## &lt;div class=&quot;form-group shiny-input-container&quot;&gt; ## &lt;label class=&quot;control-label&quot; id=&quot;what-label&quot; for=&quot;what&quot;&gt;Do you&lt;/label&gt; ## &lt;div&gt; ## &lt;select id=&quot;what&quot;&gt;&lt;option value=&quot;setosa&quot; selected&gt;setosa&lt;/option&gt; ## &lt;option value=&quot;versicolor&quot;&gt;versicolor&lt;/option&gt; ## &lt;option value=&quot;virginica&quot;&gt;virginica&lt;/option&gt;&lt;/select&gt; ## &lt;script type=&quot;application/json&quot; data-for=&quot;what&quot; data-nonempty=&quot;&quot;&gt;{&quot;plugins&quot;:[&quot;selectize-plugin-a11y&quot;]}&lt;/script&gt; ## &lt;/div&gt; ## &lt;/div&gt; ## &lt;/div&gt; "],["getting-started-with-css.html", "18.2 Getting started with CSS", " 18.2 Getting started with CSS HTML is packed full of tags You use CSS to explain how each HTML element should look If the element has this tag … it should look like this h2 { color: red; } // selector { property: value; } Selecting elements based on different types of properties: // examples from ui2() above // eg `h2` or `div` the-name { property: value; } // eg, `#what` #the-id { property: value; } // eg, `.control-label` .the-class { property: value; } You can combine the selectors together: h1,h2 // either `h1` or `h2` div h1 // an `h1` inside a `div` div &gt; h1 // an `h1` immediately inside a `div` a:hover // an `a`, but only when the user hovers over it and so on. See the wonderful tutorial at MDN for more on the various ways to select elements: https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors "],["integrate-css-files-in-your-shiny-app.html", "18.3 Integrate CSS files in your {shiny} app", " 18.3 Integrate CSS files in your {shiny} app CSS can be included in shiny apps in a few ways: inline in your ui definition in an imported file 18.3.1 Inline ui3 &lt;- function(){ tagList( h2(style = &quot;color:red;&quot;, &quot;This is red&quot;) ) } shinyApp(ui3, empty_server) print(ui3()) ## &lt;h2 style=&quot;color:red;&quot;&gt;This is red&lt;/h2&gt; 18.3.2 Using tags$style() ui4 &lt;- function(){ tagList( tags$style( &quot;h2{ color:red; }&quot; ), h2(&quot;This is red&quot;) ) } print(ui4()) ## &lt;style&gt;h2{ ## color:red; ## }&lt;/style&gt; ## &lt;h2&gt;This is red&lt;/h2&gt; 18.3.3 Using external files Provided you have this in the path ./www/style.css h2 { color: red; } Then the following will incorporate that css into your vanilla shiny app. ui5 &lt;- function() { tagList( tags$link( rel = &quot;stylesheet&quot;, type = &quot;text/css&quot;, href = &quot;www/style.css&quot; ), h2(&quot;This is red&quot;) ) } A golem-based shiny app has the command golem_add_external_resources() in the UI definition. This function pulls in any CSS or JS files. But, to add those CSS / JS files you have to use the correct golem workflow: # For CSS golem::add_css_file(&quot;style&quot;) This adds the file inst/app/www/style.css to your package. There are alternative ways to include CSS. In “Outstanding User Interfaces with Shiny”, the author recommends creating a dependency, and then including it as a tag in your UI: # R/style.R css_dep &lt;- function() { htmlDependency( name = &quot;css dep&quot;, version = &quot;1.0&quot;, src = path_to_css, stylesheet = filename ) } # In ui.R ... tagList(tag, css_dep) "],["external-resources.html", "18.4 External Resources", " 18.4 External Resources Tools “Web Developer” extension https://chrome.google.com/webstore/detail/web-developer/bfbameneiokkgbdmiekhjnmfkcnldhhm/related "],["meeting-videos-17.html", "18.5 Meeting Videos", " 18.5 Meeting Videos 18.5.1 Cohort 1 Meeting chat log LOG "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
